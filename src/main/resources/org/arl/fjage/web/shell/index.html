<!-- fjåge Web Shell

# API

- window.shellready : will be true when the shell is ready to accept input
- window.prefersColorScheme : 'dark'/'light' used to set the default colour scheme (and disable toggle)
- window.postMessage({scheme: 'dark'/'light'}) : to set the colour scheme dynamically

-->
<html>
<head>
  <title>fjåge shell</title>
  <meta charset='utf-8'/>
  <link rel="stylesheet" href="xterm.css" />
  <script src='xterm.js'></script>
  <script src='addon-attach.js'></script>
  <script src='addon-fit.js'></script>
  <script src='addon-web-links.js'></script>
  <style>
    html {
      height: 100%;
    }

    body {
      position: absolute;
      height: 100%;
      width: 100%;
      overflow: hidden;
      margin: 0px;
      padding: 0px;
    }

    .container {
      height: 100%;
      position: relative;
      background-color: #fdf6e3;
      padding-top: 0.5rem;
      padding-left: 0.5rem;
    }

    #terminal {
      display: block;
      position: relative;
      height: 100%;
      width: 100%;
    }

    .dark .container {
      background-color: #000000;
    }

    .btn-container {
      position: absolute;
      top: 5px;
      right: 20px;
      z-index: 100;
    }

    button.modeToggle {
      background-color: transparent;
      border: none;
      cursor: pointer;
      padding: 0;
      margin: 0;
    }

    .dark #schemetgl-dark {
      display: block;
    }

    .dark #schemetgl-light {
      display: none;
    }

    .light #schemetgl-dark {
      display: none;
    }

    .light #schemetgl-light {
      display: block;
    }

    *::-webkit-scrollbar {
      width: 8px;
    }

    *::-webkit-scrollbar-track {
      background: transparent;
    }

    *::-webkit-scrollbar-thumb {
      background-color: rgba(134, 134, 134, 0.46);
      border-radius: 20px;
      border: 4px solid transparent;
    }

  </style>
</head>
<body>
  <div class="container">
    <div id='terminal'></div>
    <div class="btn-container" title="Toggle Light/Dark ColorMode">
      <button class="modeToggle" id="schemetgl-bnt">
        <svg id="schemetgl-dark" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="icon" width="24px" height="24px" viewBox="0 0 24 24"><path fill="white" d="M10 7a7 7 0 0 0 12 4.9v.1c0 5.523-4.477 10-10 10S2 17.523 2 12S6.477 2 12 2h.1A6.98 6.98 0 0 0 10 7m-6 5a8 8 0 0 0 15.062 3.762A9 9 0 0 1 8.238 4.938A7.999 7.999 0 0 0 4 12"></path></svg>
        <svg id="schemetgl-light" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="icon" width="24px" height="24px" viewBox="0 0 24 24"><path fill="currentColor" d="M12 18a6 6 0 1 1 0-12a6 6 0 0 1 0 12m0-2a4 4 0 1 0 0-8a4 4 0 0 0 0 8M11 1h2v3h-2zm0 19h2v3h-2zM3.515 4.929l1.414-1.414L7.05 5.636L5.636 7.05zM16.95 18.364l1.414-1.414l2.121 2.121l-1.414 1.414zm2.121-14.85l1.414 1.415l-2.121 2.121l-1.414-1.414zM5.636 16.95l1.414 1.414l-2.121 2.121l-1.414-1.414zM23 11v2h-3v-2zM4 11v2H1v-2z"></path></svg>
      </button>
    </div>
  </div>
  <script>
    const IGNORE_KEYS = ['Meta-R', 'Meta-Shift-R'];
    const DARK_THEME = {
      background: '#000000',
      foreground: '#ffffff',
      yellow: '#c4a000',
      white: '#d3d7cf',
      green: '#4e9a06',
      blue: '#3465a4',
      red: '#cc0000',
      cursor: '#ff6e75'
    };
    const LIGHT_THEME = {
      background: '#fdf6e3',
      foreground: '#002B36',
      yellow: '#b58900',
      white: '#002B36',
      green: '#859900',
      blue: '#268bd2',
      red: '#dc322f',
      cursor: '#586e75',
      selectionBackground: '#d3c49455'
    };

    const RESIZE_DELAY = 200; // ms
    const COLS = 160
    const ROWS = 50
    const SHOW_CURSOR = "\x1B[?25h"; // show cursor
    const HIDE_CURSOR = "\x1B[?25l"; // hide cursor
    const CLEAR_LINE = '\x1B[1G\x1B[2K'; // clear line
    const CONNECTION_LOST = "\x1B[1G\x1B[2K\x1B[31m\x1B[2m(connection lost)\x1B[0m"; // connection lost message

    let currentScheme = null;
    let userScheme = false; // true if the user manually changed the scheme
    window.shellready = false;

    /**
     * Sets the color scheme for the terminal and the document body.
     * @param {Terminal} term - The terminal instance to apply the theme to.
     * @param {string} scheme - The color scheme to apply ('light' or 'dark').
     * @param {boolean} [user] - If true, indicates that the user manually changed the scheme.
     *
     */
    function setScheme(term, scheme, user) {
      if (scheme == 'light'){
        term.options.theme = LIGHT_THEME;
        document.body.classList.remove('dark');
        document.body.classList.add('light');
        currentScheme = scheme;
      }else if (scheme == 'dark'){
        term.options.theme = DARK_THEME;
        document.body.classList.remove('light');
        document.body.classList.add('dark');
        currentScheme = scheme;
      }
      if (user !== undefined) userScheme = user;
    };

    /**
     * Initializes the color schemes based on user preferences or parent document settings.
     * @param {Terminal} term - The terminal instance to apply the theme to.
     * @returns {string} - The current color scheme ('light' or 'dark').
     */
    function initializeSchemes(term){
      let theme = null;
      const schemeToggleBnt = document.getElementById('schemetgl-bnt');
      try {
        // Get the color scheme from the parent document
        if (window.frameElement && window.frameElement.dataset) {
          theme = window.frameElement.dataset.prefersColorScheme;
          if (theme != null) schemeToggleBnt.parentElement.style.display = 'none';
        } else {
          theme = window.matchMedia ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : 'light';
          schemeToggleBnt.addEventListener('click', evt => {
            setScheme(term, currentScheme == 'dark' ? 'light' : 'dark', true);
          })
        }
      } catch {
        // If we can't access the parent document (e.g., cross-origin, or not in an iframe),
        theme = window.matchMedia ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : 'light';
        schemeToggleBnt.addEventListener('click', evt => {
          setScheme(term, currentScheme == 'dark' ? 'light' : 'dark', true);
        })
      }

      // Change scheme on user preference change
      if (window.matchMedia){
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', evt => {
          if (userScheme) return;
          setScheme(term, evt.matches ? "dark" : "light");
        });
      }

      // Change scheme on message from parent document
      window.addEventListener('message', evt => {
        if (evt.data && evt.data.scheme){
          setScheme(term, evt.data.scheme, true);
        }
      });

      return theme;
    }

    window.addEventListener('load', () => {

      // Initialize terminal
      let term = new Terminal({ cols: COLS, rows: ROWS });
      let fitAddon = new FitAddon.FitAddon();
      term.loadAddon(fitAddon);
      term.loadAddon(new WebLinksAddon.WebLinksAddon());
      term.open(document.getElementById('terminal'));
      fitAddon.fit();

      // Initialize color schemes
      let initialScheme = initializeSchemes(term);
      setScheme(term, initialScheme);

      let attachAddon = null;
      const urlParams = new URLSearchParams(window.location.search);
      const url = urlParams.get('url') || (window.location.hostname + ':' + window.location.port + window.location.pathname.replace(/\/[^/]*$/, '/ws/'));
      const socket = new ReconnectingWebSocket(`ws://${url}`, {
        onopen: ws => {
          console.log('Connected to ', url);
          attachAddon = new AttachAddon.AttachAddon(ws);
          term.loadAddon(attachAddon);
          term.write(SHOW_CURSOR);       // show cursor
          term.write(CLEAR_LINE);  // clear line
          term.options.cursorBlink = true;
        },
        onmessage: (msg) => {
          window.shellready = true;
          term.focus();
        },
        onerror: (err) => {
          if (attachAddon) attachAddon.dispose();
          window.shellready = false;
          term.write(HIDE_CURSOR);     // hide cursor
          term.write(CONNECTION_LOST); // clear line and write message
          term.options.cursorBlink = false;
        },
        onclose: () => {
          if (attachAddon) attachAddon.dispose();
          window.shellready = false;
          term.write(HIDE_CURSOR);     // hide cursor
          term.write(CONNECTION_LOST); // clear line and write message
          term.options.cursorBlink = false;
        }
      });

      // Handle terminal resize
      let timeout = null;
      window.addEventListener('resize', function() {
        // clear the timeout
        clearTimeout(timeout);
        // start timing for event "completion"
        timeout = setTimeout(() => {
          fitAddon.fit();
        }, RESIZE_DELAY);
      });
    });


    /**
    * A wrapper around WebSocket that automatically reconnects
    * when the connection is lost. It has callbacks for
    * onopen, onmessage, onerror, and onclose.
    */
    class ReconnectingWebSocket{
      constructor(url, callbacks = {}) {
        this.url = url;
        this.ws = null;
        this.onopen = callbacks.onopen;
        this.onmessage = callbacks.onmessage;
        this.onerror = callbacks.onerror;
        this.onclose = callbacks.onclose;
        this.connect();
      }

      connect() {
        this.ws = new WebSocket(this.url);
        this.ws.onopen = () => {
          if (this.onopen) this.onopen(this.ws);
        };
        this.ws.onmessage = (msg) => {
          if (this.onmessage) this.onmessage(msg);
        };
        this.ws.onerror = (err) => {
          if (this.onerror) this.onerror(err);
          this.disconnect();
          setTimeout(() => this.connect(), 1000);
        };
        this.ws.onclose = () => {
          if (this.onclose) this.onclose();
          this.disconnect();
          setTimeout(() => this.connect(), 1000);
        };
      }

      disconnect() {
        if (this.ws) {
          this.ws.close();
          this.ws.onopen = null;
          this.ws.onmessage = null;
          this.ws.onerror = null;
          this.ws.onclose = null;
          this.ws = null;
        }
      }
    }
  </script>
</body>
</html>