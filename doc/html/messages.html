

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Messaging &mdash; fjåge 1.3.3-SNAPSHOT documentation</title>
    
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.3.3-SNAPSHOT',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="top" title="fjåge 1.3.3-SNAPSHOT documentation" href="index.html" />
    <link rel="next" title="Directory Services" href="services.html" />
    <link rel="prev" title="Agents and Behaviors" href="behaviors.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="services.html" title="Directory Services"
             accesskey="N">next</a></li>
        <li class="right" >
          <a href="behaviors.html" title="Agents and Behaviors"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">fjåge 1.3.3-SNAPSHOT documentation</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Messaging</a><ul>
<li><a class="reference internal" href="#sending-and-receiving-messages">Sending and receiving messages</a></li>
<li><a class="reference internal" href="#generic-messages">Generic messages</a></li>
<li><a class="reference internal" href="#alternate-syntax">Alternate syntax</a></li>
<li><a class="reference internal" href="#publishing-and-subscribing">Publishing and subscribing</a></li>
<li><a class="reference internal" href="#cloning-messages">Cloning messages</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="behaviors.html"
                        title="previous chapter">Agents and Behaviors</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="services.html"
                        title="next chapter">Directory Services</a></p>
<div id="searchbox" style="overflow:hidden;">
<script>
  (function() {
    var cx = '006023374622006758365:siprl0efik0';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//www.google.com/cse/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<h3>Search</h3>
<gcse:search></gcse:search>
</div>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="messaging">
<h1>Messaging<a class="headerlink" href="#messaging" title="Permalink to this headline">¶</a></h1>
<div class="section" id="sending-and-receiving-messages">
<h2>Sending and receiving messages<a class="headerlink" href="#sending-and-receiving-messages" title="Permalink to this headline">¶</a></h2>
<p>Agents interact with each other using messages. A <a class="reference external" href="http://org-arl.github.com/fjage/javadoc/index.html?org/arl/fjage/Message.html">Message</a> is usally tagged with a <a class="reference external" href="http://org-arl.github.com/fjage/javadoc/index.html?org/arl/fjage/Performative.html">Performative</a> that defines the purpose of the message, and is uniquely identified by a message identifier. A message is also usually associated with a sender and a recipient <cite>AgentID</cite>. If a message is sent in reply to another message, the original message&#8217;s message identifier is included as a <cite>inReplyTo</cite> property of the reply message. This allows the sender to associate the reply with the original request/query message.</p>
<p>Although the <a class="reference external" href="http://org-arl.github.com/fjage/javadoc/index.html?org/arl/fjage/Message.html">Message</a> class provides all the basic attributes of a message, it does not provide any fields to hold the message content. Typical messages will extend the <a class="reference external" href="http://org-arl.github.com/fjage/javadoc/index.html?org/arl/fjage/Message.html">Message</a> class and add relevant content fields.</p>
<p>Request message:</p>
<div class="highlight-groovy"><pre>class WeatherForecastReq extends org.arl.fjage.Message {
  WeatherForecastReq() {
    super(Performative.REQUEST)
  }
  String city, country
}</pre>
</div>
<p>Response message:</p>
<div class="highlight-groovy"><pre>class WeatherForecast extends org.arl.fjage.Message {
  WeatherForecast() {
    super(Performative.INFORM)
  }
  WeatherForecast(Message req) {
    super(req, Performative.INFORM)   // create a response with inReplyTo = req
    city = req.city
    country = req.country
  }
  String city, country
  float minTemp, maxTemp, probRain
}</pre>
</div>
<p>A client agent may send a weather forecast request to another agent named &#8220;WeatherStation&#8221;:</p>
<div class="highlight-groovy"><pre>send new WeatherForecastReq(city: 'London', country: 'UK', recipient: agent('WeatherStation'))</pre>
</div>
<p>The &#8220;WeatherStation&#8221; agent would receive the request and send back a reply. Although messages may be received using an agent&#8217;s <cite>receive()</cite> method, the preferred way to process messages is using the <a class="reference internal" href="behaviors.html#msgbehavior"><em>Message behavior</em></a>:</p>
<div class="highlight-groovy"><pre>class MyWeatherStation extends org.arl.fjage.Agent {
  void init() {
    add new MessageBehavior(WeatherForecastReq, { req -&gt;
      log.info "Weather forecast request for ${req.city}, ${req.country}"
      def rsp = new WeatherForecast(req)
      rsp.minTemp = 10
      rsp.maxTemp = 25
      rsp.probRain = 0.25
      send rsp
    })
  }
}</pre>
</div>
<p>The client agent would then receive the message, either through a message behavior or by explicitly calling <cite>receive()</cite>. An easier alternative is to send a request and wait for the associated response via the <cite>request()</cite> method:</p>
<div class="highlight-groovy"><pre>def req = new WeatherForecastReq(city: 'London', country: 'UK', recipient: agent('WeatherStation'))
def rsp = request req, 1000         // 1000 ms timeout for reply
println "The lowest temperature today is ${rsp?rsp.minTemp:'unknown'}"</pre>
</div>
</div>
<div class="section" id="generic-messages">
<h2>Generic messages<a class="headerlink" href="#generic-messages" title="Permalink to this headline">¶</a></h2>
<p>Although it usually makes sense to create message classes for specific interactions, there are times when it can be useful to send a generic message with key-value pairs. This functionality is provided by the <a class="reference external" href="http://org-arl.github.com/fjage/javadoc/index.html?org/arl/fjage/GenericMessage.html">GenericMessage</a> class, which provides a <cite>java.util.Map</cite> interface. In Groovy, this provides a nice syntax that allows the keys to work like dynamic attributes of the message. A weather forecast service implemented using generic messages is shown below.</p>
<p>Server code:</p>
<div class="highlight-groovy"><pre>import org.arl.fjage.*

class MyWeatherStation extends Agent {
  void init() {
    add new MessageBehavior({ msg -&gt;
      if (msg.performative == Performative.REQUEST &amp;&amp; msg.type == 'WeatherForecast') {
        log.info "Weather forecast request for ${msg.city}, ${msg.country}"
        def rsp = new GenericMessage(msg, Performative.INFORM)
        rsp.minTemp = 10
        rsp.maxTemp = 25
        rsp.probRain = 0.25
        send rsp
      }
    })
  }
}</pre>
</div>
<p>Client code snippet:</p>
<div class="highlight-groovy"><pre>def req = new GenericMessage(agent('WeatherStation'), Performative.REQUEST)
req.type = 'WeatherForecast'
req.city = 'London'
req.country = 'UK'
def rsp = request req, 1000         // 1000 ms timeout for reply
println "The lowest temperature today is ${rsp?rsp.minTemp:'unknown'}"</pre>
</div>
</div>
<div class="section" id="alternate-syntax">
<h2>Alternate syntax<a class="headerlink" href="#alternate-syntax" title="Permalink to this headline">¶</a></h2>
<p>Let us assume we have an <cite>AgentID</cite> for the &#8220;WeatherStation&#8221;:</p>
<div class="highlight-groovy"><pre>def weatherStation = agent('WeatherStation')</pre>
</div>
<p>It is sometimes nicer to be able to use a syntax like this:</p>
<div class="highlight-groovy"><pre>weatherStation.send new WeatherForecastReq(city: 'London', country: 'UK')</pre>
</div>
<p>or:</p>
<div class="highlight-groovy"><pre>def rsp = weatherStation.request new WeatherForecastReq(city: 'London', country: 'UK')</pre>
</div>
<p>or perhaps even:</p>
<div class="highlight-groovy"><pre>def rsp = weatherStation &lt;&lt; new WeatherForecastReq(city: 'London', country: 'UK')</pre>
</div>
<p>This alternate syntax sometimes yields more readable code, and is supported by fjåge. It is important, however, to remember that the message is sent in the context of the client agent that provided us with the <cite>AgentID</cite>. Any <cite>AgentID</cite> returned by an agent (by methods such as <cite>agent()</cite>, <cite>agentForService()</cite>, etc) is associated with or <em>owned by</em> that agent. When this <cite>AgentID</cite> is used with the above syntax, the message is actually sent using the associated agent.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you create an <cite>AgentID</cite> explicitly as <cite>new AgentID(&#8216;WeatherStation&#8217;)</cite>, it does not have an owner, and therefore cannot be used with this alternate syntax. It can, however, be used with the original syntax as a recipient for a message.</p>
</div>
</div>
<div class="section" id="publishing-and-subscribing">
<h2>Publishing and subscribing<a class="headerlink" href="#publishing-and-subscribing" title="Permalink to this headline">¶</a></h2>
<p>So far we have sent messages to recipients whose <cite>AgentID</cite> we know. There are times when we may want to publish a message without explicitly knowing who the recipients are. All agents <em>subscribing</em> to the <em>topic</em> that we publish on would then receive the published message.</p>
<p>This is supported by fjåge using the messaging constructs we have already encountered. Messages can be sent to topics in the same way that messages are sent to other agents. A topic is simply a special <cite>AgentID</cite>:</p>
<div class="highlight-groovy"><pre>def weatherChannel = topic('WeatherChannel')</pre>
</div>
<p>Instead of using a <cite>String</cite> for the topic name, it is also possible (and usually recommended) to use Enums:</p>
<div class="highlight-groovy"><pre>enum Topics {
  WEATHER_CHANNEL,
  TSUNAMI_WARNING_CHANNEL
}</pre>
</div>
<p>and</p>
<div class="highlight-groovy"><pre>def weatherChannel = topic(Topics.WEATHER_CHANNEL)</pre>
</div>
<p>Agents can subscribe to the topic of interest, typically in their <cite>init()</cite> method:</p>
<div class="highlight-groovy"><pre>subscribe weatherChannel</pre>
</div>
<p>Messages can be sent to all agents subscribing to the topic:</p>
<div class="highlight-groovy"><pre>def forecast = new WeatherForecast(city: 'London', country: 'UK', minTemp: 10, maxTemp: 25, probRain: 0.25)
weatherChannel.send forecast</pre>
</div>
<p>Agents that no longer wish to receive messages on a topic may also unsubscribe from the topic:</p>
<div class="highlight-groovy"><pre>unsubscribe weatherChannel</pre>
</div>
</div>
<div class="section" id="cloning-messages">
<h2>Cloning messages<a class="headerlink" href="#cloning-messages" title="Permalink to this headline">¶</a></h2>
<p>By default, a message delivered to another agent in the same container is the original object, and not a copy. This has some subtle but important implications. If an agent modifies a message after sending it, this can lead to unexpected behaviors.</p>
<p>Let&#8217;s take an example:</p>
<div class="highlight-groovy"><pre>def msg = new GenericMessage()
msg.text = 'Hello!'
agent('Susan').send msg
msg.text = 'Holla!'
agent('Lola').send msg</pre>
</div>
<p>If the message is delivered to Susan before the agent modifies the message, Susan gets a &#8220;Hello!&#8221; message and then Lola gets a &#8220;Holla!&#8221; message. If the message is modified after delivery to Susan, but before she has had a chance to read it, both Susan and Lola get a &#8220;Holla!&#8221; message. If the message is modified and sent to Lola before it is delivered to Susan, the recipient of the message changes, and two copies of &#8220;Holla!&#8221; get delivered to Lola and nothing gets delivered to Susan. As you can see, the behavior is indeterminate and a debugging nightmare!</p>
<p>Fortunately, there are several simple ways around this:</p>
<ol class="arabic">
<li><p class="first">Do not modify a message once it is sent. The code would then look like this:</p>
<div class="highlight-groovy"><pre>def msg = new GenericMessage()
msg.text = 'Hello!'
agent('Susan').send msg
msg = new GenericMessage()        // create a new message, don't modify the old one
msg.text = 'Holla!'
agent('Lola').send msg</pre>
</div>
</li>
<li><p class="first">Send a copy of the message, rather than the original. You can then freely modify the original:</p>
<div class="highlight-groovy"><pre>def msg = new GenericMessage()
msg.text = 'Hello!'
agent('Susan').send clone(msg)    // send a copy of the message
msg.text = 'Holla!'
agent('Lola').send msg</pre>
</div>
</li>
<li><p class="first">Ask the container to always send copies of messages rather than the original, and then you can use the original code without a problem:</p>
<div class="highlight-groovy"><pre>container.autoClone = true</pre>
</div>
</li>
</ol>
<p>The cloning of the message is accomplished using the <cite>org.apache.commons.lang3.SerializationUtils</cite> class. This performs a deep clone (clones all objects contained in the message) by serializing the entire message, and then deserializing it. This is very portable (as long as your message is <cite>Serializable</cite>), but somewhat slow. A faster deep cloning implementation is available from <cite>com.rits.cloning.Cloner</cite>, but it is less portable (it seems to have trouble dealing with some Groovy messages). If you wish to try this implementation for your application, ensure that you have the following jars in your classpath:</p>
<ul class="simple">
<li><a class="reference external" href="http://search.maven.org/remotecontent?filepath=uk/com/robust-it/cloning/1.9.0/cloning-1.9.0.jar">cloning-1.9.0.jar</a></li>
<li><a class="reference external" href="http://search.maven.org/remotecontent?filepath=org/objenesis/objenesis/1.2/objenesis-1.2.jar">objenesis-1.2.jar</a></li>
</ul>
<p>Then switch to using the fast cloner:</p>
<div class="highlight-groovy"><pre>container.cloner = Container.FAST_CLONER</pre>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="services.html" title="Directory Services"
             >next</a></li>
        <li class="right" >
          <a href="behaviors.html" title="Agents and Behaviors"
             >previous</a> |</li>
        <li><a href="index.html">fjåge 1.3.3-SNAPSHOT documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Mandar Chitre.
    </div>
  </body>
</html>